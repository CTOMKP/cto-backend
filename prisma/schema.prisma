// Prisma schema for CTO Marketplace backend
// Datasource: PostgreSQL database named cto_db
// Generator: Prisma Client for TypeScript

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Keeping existing User model shape (Int id) to avoid breaking auth
model User {
  id              Int           @id @default(autoincrement())
  name            String?
  email           String        @unique
  passwordHash    String?
  role            UserRole      @default(USER)
  // OAuth provider fields
  provider        String?
  providerId      String?       @unique
  // Circle identity fields (legacy)
  circleUserId    String?       @unique
  circleAppId     String?
  circlePinStatus String?
  // Privy identity fields
  privyUserId     String?       @unique
  privyDid        String?       @unique
  lastLoginAt     DateTime?

  // Relations
  wallets         Wallet[]
  scanResults     ScanResult[]
  userListings    UserListing[]
  uploadedMemes   Meme[]
  payments        Payment[]

  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
}

// Extend ScanResult with fields needed by marketplace while retaining Int id
model ScanResult {
  id              Int      @id @default(autoincrement())
  contractAddress String
  resultData      Json
  riskScore       Int?
  tier            String?
  summary         String?
  indexed         Boolean  @default(false)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  userId Int?
  user   User? @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([contractAddress])
  @@index([userId])
  @@index([riskScore])
}

enum UserRole {
  USER
  ADMIN
  MODERATOR
}

enum Chain {
  SOLANA
  ETHEREUM
  BSC
  SUI
  BASE
  APTOS
  NEAR
  OSMOSIS
  OTHER
  UNKNOWN
}

enum ListingCategory {
  MEME
  DEFI
  NFT
  OTHER
  UNKNOWN
}

// Listing table (renamed from MarketplaceListing)
model Listing {
  id              String          @id @default(cuid())
  contractAddress String          @unique
  chain           Chain           @default(SOLANA)
  category        ListingCategory @default(MEME)
  symbol          String?
  name            String?
  summary         String?
  riskScore       Int?
  communityScore  Float?
  tier            String?
  priceUsd        Float?
  change1h        Float?
  change6h        Float?
  change24h       Float?
  liquidityUsd    Float?
  marketCap       Float?
  volume24h       Float?
  holders         Int?
  age             String?
  txCount1h       Int?
  txCount24h      Int?
  metadata        Json?
  lastScannedAt   DateTime?
  
  // New filter fields
  lpBurnedPercentage     Float?    // LP burned percentage (0-100)
  top10HoldersPercentage  Float?    // Top 10 holders percentage (0-100)
  mintAuthDisabled       Boolean?  // Mint authority disabled
  raidingDetected        Boolean?  // Raiding activity detected
  
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  // Back-relations

  @@index([chain])
  @@index([category])
  @@index([tier])
  @@index([riskScore])
  @@index([lastScannedAt])
}

// Circle Wallets persisted for users
model Wallet {
  id                   String   @id @default(cuid())        // internal id
  circleWalletId       String?  @unique                     // Circle wallet id (legacy)
  privyWalletId        String?                              // Privy wallet id
  address              String?
  blockchain           Chain
  type                 String?                              // e.g., USER_CONTROLLED, PRIVY_EMBEDDED, PRIVY_EXTERNAL
  walletClient         String?                              // e.g., metamask, phantom, coinbase_wallet, APTOS_EMBEDDED
  description          String?
  isPrimary            Boolean  @default(false)             // Primary wallet for the user
  encryptedPrivateKey  String?                              // Encrypted private key for server-managed wallets (Aptos)

  userId         Int
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@index([userId])
  @@index([blockchain])
  @@index([address])
}

// User-created listings
model UserListing {
  id           String   @id @default(cuid())
  userId       Int
  contractAddr String
  chain        String
  title        String
  description  String
  bio          String?
  logoUrl      String?
  bannerUrl    String?
  links        Json?
  status       String   // DRAFT | PENDING_APPROVAL | PUBLISHED | REJECTED
  vettingTier  String
  vettingScore Int
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  user   User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  boosts AdBoost[]

  @@index([status])
  @@index([userId])
}

model AdBoost {
  id           String   @id @default(cuid())
  listingId    String
  type         String   // top, priority, bump, spotlight, homepage, urgent
  durationDays Int
  startDate    DateTime @default(now())
  endDate      DateTime
  createdAt    DateTime @default(now())

  // Relations
  listing UserListing @relation(fields: [listingId], references: [id], onDelete: Cascade)

  @@index([listingId])
}

// Meme images uploaded by admins (public access)
model Meme {
  id           String   @id @default(cuid())
  filename     String   // Original filename
  s3Key        String   @unique  // S3 object key (memes/filename_timestamp.jpg)
  s3Url        String   // Direct public S3 URL
  size         Int      // File size in bytes
  mimeType     String   // image/jpeg, image/png, etc.
  description  String?  // Optional description
  category     String?  // Optional category/tag
  
  // Admin who uploaded
  uploadedById Int
  uploadedBy   User     @relation(fields: [uploadedById], references: [id], onDelete: Cascade)
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([uploadedById])
  @@index([createdAt])
}

// Waitlist emails
model Waitlist {
  id        String   @id @default(cuid())
  email     String   @unique
  createdAt DateTime @default(now())
  
  @@index([createdAt])
}

// Payment tracking for listings and ad boosts
model Payment {
  id                String        @id @default(cuid())
  userId            Int
  user              User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Payment type and related entity
  paymentType       PaymentType   // LISTING | AD_BOOST
  listingId         String?       // Reference to UserListing
  adBoostId         String?       // Reference to AdBoost
  
  // Payment details
  amount            Float
  currency          String        @default("USDC")
  status            PaymentStatus @default(PENDING)
  
  // Circle transaction details
  transferId        String?       @unique  // Circle transfer ID
  txHash            String?                // Blockchain transaction hash
  fromWalletId      String?                // Source wallet (user's wallet)
  toAddress         String?                // Destination address (platform wallet)
  
  // Metadata
  description       String?
  metadata          Json?
  
  // Timestamps
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  completedAt       DateTime?
  
  @@index([userId])
  @@index([paymentType])
  @@index([status])
  @@index([transferId])
  @@index([listingId])
  @@index([adBoostId])
}

enum PaymentType {
  LISTING
  AD_BOOST
  ESCROW
  WITHDRAWAL
  OTHER
}

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REFUNDED
  CANCELLED
}